(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{301:function(e,v,_){"use strict";_.r(v);var n=_(13),t=Object(n.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("ol",[v("li",[v("p",[e._v("三级缓存解决循环依赖问题的关键是什么？为什么通过提前暴露对象能解决")]),e._v(" "),v("p",[e._v("实例化和初始化分开操作，在中间过程中给其他对象赋值的时候，并不是一个完整对象，而是把半成品对象赋值给了其他对象")])]),e._v(" "),v("li",[v("p",[e._v("如果只使用一级缓存能否解决问题？")]),e._v(" "),v("p",[e._v("不能，在整个过程中，缓存中放的是半成品和成品对象，如果只有一级缓存，那么成品和半成品都会放在一级缓存中，有可能在获取过程中获取到半成品对象，此时半成品对象是无法使用的，不能直接进行相关的处理，因此要把半成品和成品对象分隔开。")])]),e._v(" "),v("li",[v("p",[e._v("二级缓存能否解决循环依赖问题？")]),e._v(" "),v("p",[e._v("如果我们能保证所有的bean对象都不去调用"),v("code",[e._v("getEarlyBeanReference")]),e._v("方法，可以是使用二级缓存。")])]),e._v(" "),v("li",[v("p",[e._v("为什么要用三级缓存？")]),e._v(" "),v("p",[e._v("本质在于解决"),v("code",[e._v("aop")]),e._v("代理问题。三级缓存存放的是"),v("code",[e._v("Lambda")]),e._v("表达式形式的"),v("code",[e._v("beanFactory")]),e._v("实现类，从三级缓存取bean的时候，会回调"),v("code",[e._v("getEarlyBeanReference")]),e._v("方法获取bean的代理类，然后将代理类放入二级缓存中，二级缓存放的是代理半成品。")])])])])}),[],!1,null,null,null);v.default=t.exports}}]);