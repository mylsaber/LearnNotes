(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{303:function(v,e,_){"use strict";_.r(e);var t=_(13),o=Object(t.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h3",{attrs:{id:"简单工厂模式-factory"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简单工厂模式-factory"}},[v._v("#")]),v._v(" 简单工厂模式（Factory）")]),v._v(" "),e("p",[v._v("应用场景：又叫做静态工厂方法（"),e("code",[v._v("StaticFactory Method")]),v._v("）模式，但不属于 23 种设计模式之一。  简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 "),e("code",[v._v("Spring")]),v._v(" 中的 "),e("code",[v._v("BeanFactory")]),v._v("  就是简单工厂模式的体现，根据传入一个唯一的标识来获得 "),e("code",[v._v("Bean")]),v._v(" 对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。")]),v._v(" "),e("h3",{attrs:{id:"工厂方法模式-factory-method"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法模式-factory-method"}},[v._v("#")]),v._v(" 工厂方法模式（Factory Method）")]),v._v(" "),e("p",[v._v("应用场景：通常由应用程序直接使用 "),e("code",[v._v("new")]),v._v(" 创建新的对象，为了将对象的创建和使用相分离，采用工厂模式，即应用程序将对象的创建及初始化职责交给工厂对象。 一般情况下，应用程序有自己的工厂对象来创建 "),e("code",[v._v("Bean")]),v._v("。如果将应用程序自己的工厂对象交给"),e("code",[v._v("Spring")]),v._v("管理,那么"),e("code",[v._v("Spring")]),v._v("管理的就不是普通的"),e("code",[v._v("Bean")]),v._v(",而是工厂 Bean。")]),v._v(" "),e("h3",{attrs:{id:"单例模式-singleton"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单例模式-singleton"}},[v._v("#")]),v._v(" 单例模式（Singleton）")]),v._v(" "),e("p",[v._v("应用场景：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 "),e("code",[v._v("Spring")]),v._v(" 中的单例模式完成了后半句话，即提供了全局的访问点 "),e("code",[v._v("BeanFactory")]),v._v("。但没有从构造器级别去控制单例，这是因为"),e("code",[v._v("Spring")]),v._v("管理的是是任意的"),e("code",[v._v("Java")]),v._v("对象。 "),e("code",[v._v("Spring")]),v._v("下默认的"),e("code",[v._v("Bean")]),v._v("均为单例。")]),v._v(" "),e("h3",{attrs:{id:"原型模式-prototype"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型模式-prototype"}},[v._v("#")]),v._v(" 原型模式（Prototype）")]),v._v(" "),e("p",[v._v("应用场景：原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。 所谓原型模式，就是"),e("code",[v._v("Java")]),v._v("中的克隆技术，以某个对象为原型。复制出新的对象。显然新的对象具备原型对象的特点，效率高（避免了重新执行构造过程步骤）。")]),v._v(" "),e("h3",{attrs:{id:"代理模式-proxy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理模式-proxy"}},[v._v("#")]),v._v(" 代理模式（Proxy）")]),v._v(" "),e("p",[v._v("应用场景：为其他对象提供一种代理以控制对这个对象的访问。从结构上来看和"),e("code",[v._v("Decorator")]),v._v("模式类似， 但"),e("code",[v._v("Proxy")]),v._v("是控制，更像是一种对功能的限制，而"),e("code",[v._v("Decorator")]),v._v(" 是增加职责。 "),e("code",[v._v("Spring")]),v._v("的"),e("code",[v._v("Proxy")]),v._v("模式在"),e("code",[v._v("AOP")]),v._v("中有体现，比如"),e("code",[v._v("JdkDynamicAopProxy")]),v._v("和"),e("code",[v._v("Cglib2AopProxy")]),v._v("。")]),v._v(" "),e("h3",{attrs:{id:"策略模式-strategy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#策略模式-strategy"}},[v._v("#")]),v._v(" 策略模式（Strategy）")]),v._v(" "),e("p",[v._v("应用场景：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。"),e("code",[v._v("Spring")]),v._v("中在实例化对象的时候用到"),e("code",[v._v("Strategy")]),v._v("模式，在"),e("code",[v._v("SimpleInstantiationStrategy")]),v._v("有使用。")]),v._v(" "),e("h3",{attrs:{id:"模板方法模式-template-method"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模板方法模式-template-method"}},[v._v("#")]),v._v(" 模板方法模式（Template Method）")]),v._v(" "),e("p",[v._v("定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。"),e("code",[v._v("Template Method")]),v._v("使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 "),e("code",[v._v("TemplateMethod")]),v._v("模式一般是需要继承的。这里想要探讨另一种对"),e("code",[v._v("TemplateMethod")]),v._v("的理解。"),e("code",[v._v("Spring")]),v._v("中的"),e("code",[v._v("JdbcTemplate")]),v._v("，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到"),e("code",[v._v("JdbcTemplate")]),v._v("已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入 "),e("code",[v._v("JdbcTemplate")]),v._v("的方法中。但是变化的东西是一段代码，而且这段代码会用到"),e("code",[v._v("JdbcTemplate")]),v._v("中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵"),e("code",[v._v("JdbcTemplate")]),v._v("中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到"),e("code",[v._v("JdbcTemplate")]),v._v("，从而完成了调用。这就是"),e("code",[v._v("Template Method")]),v._v("不需要继承的另一种实现方式。")]),v._v(" "),e("h3",{attrs:{id:"委派模式-delegate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#委派模式-delegate"}},[v._v("#")]),v._v(" 委派模式（Delegate）")]),v._v(" "),e("p",[v._v("应用场景：不属于 23 种设计模式之一，是面向对象设计模式中常用的一种模式。这种模式的原理为类 B 和类 A 是两个互相没有任何关系的类，B  具有和 A 一模一样的方法和属性；并且调用 B 中的方法，属性就是调用 A 中同名的方法和属性。B 好像就是一个受 A  授权委托的中介。第三方的代码不需要知道 A 的 存在，也不需要和 A 发生直接的联系，通过 B 就可以直接使用 A 的功能，这样既能够使用到 A 的各种功 能，又能够很好的将 A 保护起来了，一举两得。")]),v._v(" "),e("h3",{attrs:{id:"适配器模式-adapter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式-adapter"}},[v._v("#")]),v._v(" 适配器模式（Adapter）")]),v._v(" "),e("p",[e("code",[v._v("Spring AOP")]),v._v(" 模块对"),e("code",[v._v("BeforeAdvice")]),v._v("、"),e("code",[v._v("AfterAdvice")]),v._v("、"),e("code",[v._v("ThrowsAdvice")]),v._v("三种通知类型的支持实际上是借助适配器模式来实现的，这样的好处是使得框架允许用户向框架中加入自己想要支持的任何一种通知类型，上述三种通知类型是"),e("code",[v._v("Spring AOP")]),v._v("模块定义的，它们是 "),e("code",[v._v("AOP")]),v._v("联盟定义的 Advice 的子类型。")]),v._v(" "),e("h3",{attrs:{id:"装饰器模式-decorator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#装饰器模式-decorator"}},[v._v("#")]),v._v(" 装饰器模式（Decorator）")]),v._v(" "),e("p",[v._v("应用场景：在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在 "),e("code",[v._v("Spring")]),v._v("和"),e("code",[v._v("Hibernate")]),v._v("框架中总是配置一个数据源，因而"),e("code",[v._v("SessionFactory")]),v._v("的"),e("code",[v._v("DataSource")]),v._v("属性总是指向这个数据源并且恒定不变，所有"),e("code",[v._v("DAO")]),v._v("在使用"),e("code",[v._v("SessionFactory")]),v._v("  的时候都是通过这个数据源访问数据库。但是现在，由于项目的需要，我们的"),e("code",[v._v("DAO")]),v._v("在访问"),e("code",[v._v("SessionFactory")]),v._v("的时候都不得不在多个数据源中不断切换，问题就出现了：如何让"),e("code",[v._v("SessionFactory")]),v._v("在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在"),e("code",[v._v("Spring")]),v._v("的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？\n首先想到在"),e("code",[v._v("Spring")]),v._v("的"),e("code",[v._v("ApplicationContext")]),v._v("中配置所有的"),e("code",[v._v("DataSource")]),v._v("。这些"),e("code",[v._v("DataSource")]),v._v("可能是各种不同类型的，比如不同的数据库："),e("code",[v._v("Oracle")]),v._v("、"),e("code",[v._v("SQL Server")]),v._v("、"),e("code",[v._v("MySQL")]),v._v("等，也可能是不同的数据源：比如"),e("code",[v._v("Apache")]),v._v("提供的"),e("code",[v._v("org.apache.commons.dbcp.BasicDataSource")]),v._v("，"),e("code",[v._v("Spring")]),v._v("提供的"),e("code",[v._v("org.springframework.jndi.JndiObjectFactoryBean")]),v._v("等。然后"),e("code",[v._v("SessionFactory")]),v._v("根据客户的每次请求，将"),e("code",[v._v("DataSource")]),v._v("属性设置成不同的数据源，以到达切换数据源的目的。"),e("code",[v._v("Spring")]),v._v("中用到的包装器模式在类名上有两种表现：一种是类名中含有"),e("code",[v._v("Wrapper")]),v._v("，另一种是类名中含有"),e("code",[v._v("Decorator")]),v._v("。基本上都是动态地给一个对象添加一些额外的职责。")]),v._v(" "),e("h3",{attrs:{id:"观察者模式-observer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式-observer"}},[v._v("#")]),v._v(" 观察者模式（Observer）")]),v._v(" "),e("p",[v._v("应用场景：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。"),e("code",[v._v("Spring")]),v._v("中"),e("code",[v._v("Observer")]),v._v("模式常用的地方是"),e("code",[v._v("Listener")]),v._v("的实现。如"),e("code",[v._v("ApplicationListener")]),v._v("。")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("设计模式")]),v._v(" "),e("th",[v._v("归纳")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("工厂模式（Factory）")]),v._v(" "),e("td",[v._v("只对结果负责")])]),v._v(" "),e("tr",[e("td",[v._v("单例模式（Singleton）")]),v._v(" "),e("td",[v._v("保证对象独一无二")])]),v._v(" "),e("tr",[e("td",[v._v("适配器模式（Adapter）")]),v._v(" "),e("td",[v._v("转换头（兼容）")])]),v._v(" "),e("tr",[e("td",[v._v("装饰器模式（Decorator）")]),v._v(" "),e("td",[v._v("包装，但不改变本质")])]),v._v(" "),e("tr",[e("td",[v._v("代理模式（Proxy）")]),v._v(" "),e("td",[v._v("通过代理来做事")])]),v._v(" "),e("tr",[e("td",[v._v("观察者模式（Observer）")]),v._v(" "),e("td",[v._v("完成时通时我")])]),v._v(" "),e("tr",[e("td",[v._v("策略模式（Strategy）")]),v._v(" "),e("td",[v._v("可以选择多个路径，最终达到同样目的")])]),v._v(" "),e("tr",[e("td",[v._v("模板模式（Template）")]),v._v(" "),e("td",[v._v("流程标准化，部分步骤可以自定义")])]),v._v(" "),e("tr",[e("td",[v._v("委派模式（Delegate）")]),v._v(" "),e("td",[v._v("接到工作，委派给其他类来实现")])]),v._v(" "),e("tr",[e("td",[v._v("原型模式（Prototype）")]),v._v(" "),e("td",[v._v("通过原型，创建另一个定制化对象")])])])])])}),[],!1,null,null,null);e.default=o.exports}}]);