(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{346:function(v,_,e){"use strict";e.r(_);var s=e(13),l=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[_("strong",[v._v("redis有哪些数据结构")])]),v._v(" "),_("ul",[_("li",[v._v("字符串String")]),v._v(" "),_("li",[v._v("字典Hash")]),v._v(" "),_("li",[v._v("列表List")]),v._v(" "),_("li",[v._v("集合Set")]),v._v(" "),_("li",[v._v("有序集合SortedSet")])]),v._v(" "),_("p",[v._v("它还有三种特殊的数据结构类型")]),v._v(" "),_("ul",[_("li",[v._v("Geospatial")]),v._v(" "),_("li",[v._v("Hyperloglog")]),v._v(" "),_("li",[v._v("Bitmap")])]),v._v(" "),_("p",[_("strong",[v._v("Redis为什么这么快？")])]),v._v(" "),_("ul",[_("li",[v._v("基于内存存储实现")]),v._v(" "),_("li",[v._v("高效的数据结构")]),v._v(" "),_("li",[v._v("合理的线程模型\n"),_("ul",[_("li",[v._v("I/O 多路复用")])])]),v._v(" "),_("li",[v._v("单线程模型\n"),_("ul",[_("li",[v._v("Redis是单线程模型的，而单线程避免了CPU不必要的上下文切换和竞争锁的消耗。也正因为是单线程，如果某个命令执行过长（如hgetall命令），会造成阻塞。Redis是面向快速执行场景的数据库。，所以要慎用如smembers和lrange、hgetall等命令。")]),v._v(" "),_("li",[v._v("Redis 6.0 引入了多线程提速，它的执行命令操作内存的仍然是个单线程。")])])])]),v._v(" "),_("p",[_("strong",[v._v("什么是缓存击穿、缓存穿透、缓存雪崩？")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("缓存穿透")]),v._v("：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。")]),v._v(" "),_("li",[_("strong",[v._v("缓存雪奔：")]),v._v(" 指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至down机。")]),v._v(" "),_("li",[_("strong",[v._v("缓存击穿：")]),v._v(" 指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。")])]),v._v(" "),_("p",[_("strong",[v._v("Redis 过期策略和内存淘汰策略")])]),v._v(" "),_("p",[v._v("Redis中同时使用了"),_("strong",[v._v("惰性过期和定期过期")]),v._v("两种过期策略。")]),v._v(" "),_("p",[_("strong",[v._v("Redis 内存淘汰策略")])]),v._v(" "),_("ul",[_("li",[v._v("volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰；")]),v._v(" "),_("li",[v._v("allkeys-lru：当内存不足以容纳新写入数据时，从所有key中使用LRU（最近最少使用）算法进行淘汰。")]),v._v(" "),_("li",[v._v("volatile-lfu：4.0版本新增，当内存不足以容纳新写入数据时，在过期的key中，使用LFU算法进行删除key。")]),v._v(" "),_("li",[v._v("allkeys-lfu：4.0版本新增，当内存不足以容纳新写入数据时，从所有key中使用LFU算法进行淘汰；")]),v._v(" "),_("li",[v._v("volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的key中，随机淘汰数据；。")]),v._v(" "),_("li",[v._v("allkeys-random：当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。")]),v._v(" "),_("li",[v._v("volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被淘汰；")]),v._v(" "),_("li",[v._v("noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。")])]),v._v(" "),_("p",[_("strong",[v._v("假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？")])]),v._v(" "),_("p",[v._v("使用keys指令可以扫出指定模式的key列表。")]),v._v(" "),_("p",[v._v("对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？")]),v._v(" "),_("p",[v._v("这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。")]),v._v(" "),_("p",[_("strong",[v._v("使用过Redis做异步队列么，你是怎么用的？")])]),v._v(" "),_("p",[v._v("一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。")]),v._v(" "),_("p",[v._v("如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。")]),v._v(" "),_("p",[v._v("如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。")]),v._v(" "),_("p",[v._v("如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。")]),v._v(" "),_("p",[v._v("如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。")]),v._v(" "),_("p",[_("strong",[v._v("如果有大量的key需要设置同一时间过期，一般需要注意什么？")])]),v._v(" "),_("p",[v._v("如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。")]),v._v(" "),_("p",[_("strong",[v._v("Redis如何做持久化的？")])]),v._v(" "),_("p",[v._v("bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。")]),v._v(" "),_("p",[v._v("对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。")]),v._v(" "),_("p",[v._v("对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。")]),v._v(" "),_("p",[_("strong",[v._v("Redis的同步机制了解么？")])]),v._v(" "),_("p",[v._v("Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。")]),v._v(" "),_("p",[_("strong",[v._v("是否使用过Redis集群，集群的原理是什么？")])]),v._v(" "),_("p",[v._v("Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。")]),v._v(" "),_("p",[v._v("Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。")])])}),[],!1,null,null,null);_.default=l.exports}}]);