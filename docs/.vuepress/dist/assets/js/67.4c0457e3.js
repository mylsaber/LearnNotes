(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{337:function(e,r,t){"use strict";t.r(r);var v=t(13),s=Object(v.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[e._v("#")]),e._v(" 概念")]),e._v(" "),r("h2",{attrs:{id:"什么是kubernetes"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是kubernetes"}},[e._v("#")]),e._v(" 什么是Kubernetes")]),e._v(" "),r("p",[e._v("Kubernetes 是一个可移植的，可扩展的开源平台，用于管理容器化的工作负载和服务，方便了声明式配置和自动化。它拥有一个庞大且快速增长的生态系统。Kubernetes 的服务，支持和工具广泛可用。")]),e._v(" "),r("h3",{attrs:{id:"为什么需要kubernetes-他能做什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要kubernetes-他能做什么"}},[e._v("#")]),e._v(" 为什么需要Kubernetes，他能做什么")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("服务发现和负载均衡")]),e._v(" "),r("p",[e._v("Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。")])]),e._v(" "),r("li",[r("p",[e._v("存储编排")]),e._v(" "),r("p",[e._v("Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。")])]),e._v(" "),r("li",[r("p",[e._v("自动部署和回滚")]),e._v(" "),r("p",[e._v("你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。")])]),e._v(" "),r("li",[r("p",[e._v("自动完成装箱计算")]),e._v(" "),r("p",[e._v("Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。")])]),e._v(" "),r("li",[r("p",[e._v("自我修复")]),e._v(" "),r("p",[e._v("Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。")])]),e._v(" "),r("li",[r("p",[e._v("密钥与配置管理")]),e._v(" "),r("p",[e._v("Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。")])])]),e._v(" "),r("h2",{attrs:{id:"kubernetes组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes组件"}},[e._v("#")]),e._v(" Kubernetes组件")]),e._v(" "),r("p",[e._v("一个Kubernetes集群由一组被称为节点的机器组成，这些节点上运行Kubernetes所管理的容器化应用，集群具有至少一个工作节点。")]),e._v(" "),r("p",[e._v("工作节点托管作为应用负载的组件的 Pod 。控制平面管理集群中的工作节点和 Pod 。 为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。")]),e._v(" "),r("p",[r("img",{attrs:{src:"D:%5CJavaLearn%5Clearn-notes%5CKubernetes%5Ccomponents-of-kubernetes.svg",alt:""}})]),e._v(" "),r("h3",{attrs:{id:"控制平面组件-control-plane-components"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#控制平面组件-control-plane-components"}},[e._v("#")]),e._v(" 控制平面组件（Control Plane Components）")]),e._v(" "),r("p",[e._v("控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 "),r("code",[e._v("replicas")]),e._v(" 字段时，启动新的 pod）。")]),e._v(" "),r("p",[e._v("控制平面组件可以在集群中的任何节点上运行，然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件，并且不会在此计算机上运行用户容器")]),e._v(" "),r("h4",{attrs:{id:"kube-apiserver"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kube-apiserver"}},[e._v("#")]),e._v(" kube-apiserver")]),e._v(" "),r("p",[e._v("API 服务器是 Kubernetes 控制面 的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。")]),e._v(" "),r("p",[e._v("Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。")]),e._v(" "),r("h4",{attrs:{id:"etcd"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#etcd"}},[e._v("#")]),e._v(" etcd")]),e._v(" "),r("p",[e._v("etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。")]),e._v(" "),r("p",[e._v("您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。")]),e._v(" "),r("h4",{attrs:{id:"kube-scheduler"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kube-scheduler"}},[e._v("#")]),e._v(" kube-scheduler")]),e._v(" "),r("p",[e._v("控制平面组件，负责监视新创建的、未指定运行 节点（node）的 Pods，选择节点让 Pod 在上面运行。")]),e._v(" "),r("p",[e._v("调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。")]),e._v(" "),r("h4",{attrs:{id:"kube-controller-manager"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kube-controller-manager"}},[e._v("#")]),e._v(" kube-controller-manager")]),e._v(" "),r("p",[e._v("运行 控制器 进程的控制平面组件。")]),e._v(" "),r("p",[e._v("从逻辑上讲，每个 控制器 都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。")]),e._v(" "),r("p",[e._v("这些控制器包括:")]),e._v(" "),r("ul",[r("li",[e._v("节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应")]),e._v(" "),r("li",[e._v("任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成")]),e._v(" "),r("li",[e._v("端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)")]),e._v(" "),r("li",[e._v("服务帐户和令牌控制器（Service Account & Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌")])]),e._v(" "),r("h4",{attrs:{id:"cloud-controller-manager"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cloud-controller-manager"}},[e._v("#")]),e._v(" cloud-controller-manager")]),e._v(" "),r("p",[e._v("云控制器管理器是指嵌入特定云的控制逻辑的 控制平面 组件。 云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。")]),e._v(" "),r("p",[r("code",[e._v("cloud-controller-manager")]),e._v(" 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。")]),e._v(" "),r("p",[e._v("与 "),r("code",[e._v("kube-controller-manager")]),e._v(" 类似，"),r("code",[e._v("cloud-controller-manager")]),e._v(" 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。")]),e._v(" "),r("p",[e._v("下面的控制器都包含对云平台驱动的依赖：")]),e._v(" "),r("ul",[r("li",[e._v("节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除")]),e._v(" "),r("li",[e._v("路由控制器（Route Controller）: 用于在底层云基础架构中设置路由")]),e._v(" "),r("li",[e._v("服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器")])]),e._v(" "),r("h3",{attrs:{id:"node组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#node组件"}},[e._v("#")]),e._v(" Node组件")]),e._v(" "),r("p",[e._v("节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。")]),e._v(" "),r("h4",{attrs:{id:"kubelet"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kubelet"}},[e._v("#")]),e._v(" kubelet")]),e._v(" "),r("p",[e._v("一个在集群中每个"),r("strong",[e._v("节点（node）"),r("strong",[e._v("上运行的代理，它保证")]),e._v("容器（containers）"),r("strong",[e._v("都运行在")]),e._v("Pod")]),e._v("中")]),e._v(" "),r("p",[e._v("kubelet 接收一组通过各类机制提供给它的PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。kubelet不会管理不是由Kubernetes创建的容器。")]),e._v(" "),r("h4",{attrs:{id:"kube-proxy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kube-proxy"}},[e._v("#")]),e._v(" kube-proxy")]),e._v(" "),r("p",[e._v("kube-proxy 是集群中每个节点上运行的网络代理，实现 Kubernetes **服务（Service）**概念的一部分。")]),e._v(" "),r("p",[e._v("kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与Pod进行网络通信。")]),e._v(" "),r("p",[e._v("如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。")]),e._v(" "),r("h3",{attrs:{id:"容器运行时-container-runtime"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容器运行时-container-runtime"}},[e._v("#")]),e._v(" 容器运行时（Container Runtime")]),e._v(" "),r("p",[e._v("容器运行环境是负责运行容器的软件。")]),e._v(" "),r("p",[e._v("Kubernetes 支持容器运行时，例如 Docker、 containerd、CRI-O 以及 Kubernetes CRI (容器运行环境接口) 的其他任何实现。")]),e._v(" "),r("h3",{attrs:{id:"插件-addons"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#插件-addons"}},[e._v("#")]),e._v(" 插件（Addons）")]),e._v(" "),r("p",[e._v("插件使用 Kubernetes 资源（DaemonSet、 Deployment等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 "),r("code",[e._v("kube-system")]),e._v(" 命名空间。")]),e._v(" "),r("h4",{attrs:{id:"dns"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dns"}},[e._v("#")]),e._v(" DNS")]),e._v(" "),r("p",[e._v("尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该 有"),r("strong",[e._v("集群 DNS")]),e._v("， 因为很多示例都需要 DNS 服务。")]),e._v(" "),r("p",[e._v("集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。")]),e._v(" "),r("p",[e._v("Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。")]),e._v(" "),r("h4",{attrs:{id:"web-界面-仪表盘"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#web-界面-仪表盘"}},[e._v("#")]),e._v(" Web 界面（仪表盘）")]),e._v(" "),r("p",[r("strong",[e._v("Dashboard")]),e._v("是 Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。")]),e._v(" "),r("h4",{attrs:{id:"容器资源监控"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容器资源监控"}},[e._v("#")]),e._v(" 容器资源监控")]),e._v(" "),r("p",[r("strong",[e._v("容器资源监控")]),e._v("将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。")]),e._v(" "),r("h4",{attrs:{id:"集群层面日志"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#集群层面日志"}},[e._v("#")]),e._v(" 集群层面日志")]),e._v(" "),r("p",[r("strong",[e._v("集群层面日志")]),e._v(" 机制负责将容器的日志数据 保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。")])])}),[],!1,null,null,null);r.default=s.exports}}]);