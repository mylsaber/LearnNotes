### Java

#### 面向对象有哪些特征

- 封装：隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。
- 继承：是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。
- 多态：就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

#### `ArrayList`和`linkedList`有什么区别

- 数据结构不同：`ArrayList`底层使用Array（数组）实现，`LinkedList`底层使用链表实现
- `ArrayList`可以看做是一个能够自动增长的数组，扩容时按照当前容量1.5倍进行扩容

#### 高并发集合有哪些

- 早期线程安全集合

  `Vector`：类似于`ArrayList`，可变数组实现

  `HashTable`：类似于`HashMap`，但是它的key和value都不能为null

- `Collections`包装方法

  ```java
  List<E> synArrayList = Collections.synchronizedList(new ArrayList<E>());
  
  Set<E> synHashSet = Collections.synchronizedSet(new HashSet<E>());
  
  Map<K,V> synHashMap = Collections.synchronizedMap(new HashMap<K,V>());
  ```

  `Collections`针对每种集合都声明了一个线程安全的包装类，在原集合的基础上添加了锁对象，集合中的每个方法都通过这个锁对象实现同步

- `java.util.concurrent`包中的集合

  1. `ConcurrentHashMap`：

     `ConcurrentHashMap`和`HashTable`都是线程安全的集合，它们的不同主要是加锁粒度上的不同。`HashTable`的加锁方法是给每个方法加上synchronized关键字，这样锁住的是整个Table对象。而`ConcurrentHashMap`是更细粒度的加锁

     在`JDK1.8`之前，`ConcurrentHashMap`加的是分段锁，也就是`Segment`锁，每个`Segment`含有整个`table`的一部分，这样不同分段之间的并发操作就互不影响
     `JDK1.8`对此做了进一步的改进，它取消了`Segment`字段，直接在`table`元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率

  2. `CopyOnWriteArrayList`和`CopyOnWriteArraySet`

     它们是加了写锁的`ArrayList`和`ArraySet`，锁住的是整个对象，但读操作可以并发执行，`CopyOnWriteArraySet`底层使用`CopyOnWriteArrayList`实现

  3. 除此之外还有`ConcurrentSkipListMap`、`ConcurrentSkipListSet`、`ConcurrentLinkedQueue`、`ConcurrentLinkedDeque`等，至于为什么没有`ConcurrentArrayList`，原因是无法设计一个通用的而且可以规避`ArrayList`的并发瓶颈的线程安全的集合类，只能锁住整个`list`，这用`Collections`里的包装类就能办到

#### jdk8新特性

#### java中抽象类和接口有什么区别

- 构造方法：抽象类可以有构造方法，接口中不能有构造方法
- 成员变量：抽象类可以有普通成员变量，任意访问类型的的静态成员变量。接口中不能有普通成员变量，只能有`public static final`修饰的静态变量
- 方法：抽象类可以包含普通方法和抽象方法，接口中所有方法都是必须是抽象方法。抽象类中可以包含静态方法，接口中不能包含静态方法
- 访问类型：抽象类中方法可以是`public`、`protected`、默认，但是接口中的抽象方法只能是`public`，并且默认是`public abstract`类型
- 实现：抽象类单继承，接口可以多继承
- 应用上：抽象类主要用于抽象类别，接口主要用来抽象方法功能，当我们来抽象一个狗的对象时，可以使用抽象类来描述狗，具体到那种类型的狗时可以继承这个抽象类，当我们描述一类动作时，比如猫和狗都有跑这个能力，就可以实现接口来实现跑这个功能

#### `hashcode`和`equals`如何使用

自定义类中的的`equals`和==是一样的，比较的是内存地址，当重写`equals`方法时，必须也要同事重写`hashcode`方法，因为在比如`HashMap`中，比较两个对象是否相等，首先是调用`hashcode`来比较，再用`equals`比较，如果使用`equals`比较相同，那么比较`hashcode`时也必须相同

#### `java`代理的几种实现方式

- 静态代理：自己手动实现
- 动态代理：
  1. `JDK`动态代理，代理类必须实现接口
  2. `CGLIB`动态代理，代理类可以不用实现接口

#### ==和`equals`有哪些区别

`Object`类中，`equals`用==实现，对象都是比较内存地址，基本数据类型比较值，但是可以重写`equals`方法来实现内容比较，比如`String`中`equals`方法就是重写过的。

#### `java`异常处理机制是什么

处理机制为：抛出异常，捕捉异常

抛出异常的方法：`throws`和`throw`：

- `throws`：通常用在声明方法时，用来指定方法可能抛出的异常，多个异常使用逗号分隔，`throws`关键字将异常抛给上一级，如果不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的代码。

- `throw`：通常用在方法体中或者用来抛出用户自定义异常，并且抛出一个异常对象。程序在执行到throw语句时立即停止，如果要捕捉`throw`抛出的异常，则必须使用`try-catch`语句块或者`try-catch-finally`语句。

  `try-catch-finally`语句：首先执行`try`中代码，如果代码执行正常就就继续执行`finally`代码块，如果发生异常且被`catch`捕获到就执行`catch`代码块，然后执行`finally`代码块。

#### `java`中重写和重载的区别

重写：实质是子类对父类的函数进行了重定义。若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法，如需父类中原有的方法则可使用 super 关键字。重写方法访问修饰符不能小于被重写方法，抛出的异常必须是被重写方法抛出异常或者其子异常

重载：是让类以统一的方式处理不同类型数据的一种手段，实质表现就是多个具有不同的参数个数或者类型的同名函数（返回值类型可随意，不能以返回类型作为重载函数的区分标准）同时存在于同一个类中，是一个类中多态性的一种表现，调用时通过参数判断具体方法。

重载与重写是 `Java 多态性`的不同表现。

- 重写是父类与子类之间多态性的表现，在运行时起作用（动态多态性，譬如实现动态绑定）
- 而重载是一个类中多态性的表现，在编译时起作用（静态多态性，譬如实现静态绑定）。

#### `String`、`StringBuffer`、`StringBuilder`区别和使用场景

`String`：字符数组被final修饰，不可变，如果进行字符串操作是新建一个`String`。

`StringBuffer`：可变字符串，线程安全，适用于多线程环境操作字符串

`StringBuilder`：可变字符串，线程不安全，适用于单线程环境操作字符串，

#### 怎么声明一个类不会被继承

- 使用`final`修饰类
- 私有化构造器

#### `HashMap`和`HashTable`的区别

线程安全不同：

- `Hashtable`的几乎所有函数都是同步的，即它是线程安全的，支持多线程。
- `HashMap`的函数则是非同步的，它不是线程安全的。

对null值的处理不同：

- `HashMap`的key、value都可以为null。
- `Hashtable`的key、value都不可以为null。

容量的初始值 和 增加方式都不一样：

- `HashMap`默认的容量大小是16；增加容量时，每次将容量变为“原始容量x2”。
- `Hashtable`默认的容量大小是11；增加容量时，每次将容量变为“原始容量x2 + 1”。

添加key-value时的hash值算法不同

- `HashMap`添加元素时，是使用自定义的哈希算法。
- `Hashtable`没有自定义哈希算法，而直接采用的key的hashCode()。

#### `HashMap`有哪些线程安全的方式

- 使用`Collections.synchronizedMap(new HashMap<String, Strinig>())`获取线程安全`Map`
- 使用`ConcurrentHashMap`

#### `HashMap`在扩容上做了哪些优化

`JDK7`

- `HashMap`的内部数据保存的都是链表。因此逻辑相对简单：在准备好新的数组后，map会遍历数组的每个“桶”，然后遍历桶中的每个Entity，重新计算其hash值（也有可能不计算），找到新数组中的对应位置，以头插法插入新的链表。

`JDK8`扩容

1. 空参数的构造函数：实例化的`HashMap`默认内部数组是null，即没有实例化。第一次调用put方法时，则会开始第一次初始化扩容，长度为16。
2. 有参构造函数：用于指定容量。会根据指定的正整数找到不小于指定容量的2的幂数，将这个数设置赋值给**阈值**（threshold）。第一次调用put方法时，会将阈值赋值给容量，然后让 阈值=容量*负载因子（因此并不是我们手动指定了容量就一定不会触发扩容，超过阈值后一样会扩容！！)
3. 如果不是第一次扩容，则容量变为原来的2倍，阈值也变为原来的2倍。*（容量和阈值都变为原来的2倍时，负载因子还是不变）*

`JDK8`性能有了大大的提升：由于数组的容量是以2的幂次方扩容的，那么一个Entity在扩容时，新的位置要么在原位置，要么在原长度+原位置的位置。数组长度变为原来的2倍，表现在二进制上就是多了一个高位参与数组下标确定。此时，一个元素通过hash转换坐标的方法计算后，恰好出现一个现象：最高位是0则坐标不变，最高位是1则坐标变为“10000+原坐标”，即“原长度+原坐标”。

#### 为什么`HashMap`扩容的时候是两倍

1. 源码计算存储位置时`(n-1)&hash(key)`，容量为2的幂次方时，`n-1`的二进制会全为1，位运算时可以充分散列，避免不必要的哈希冲突。
2. 扩容迁移的时候不需要再重新通过哈希定位新的位置了。扩容后，元素新的位置，要么在原脚标位，要么在原脚标位+扩容长度这么一个位置，是否移位，由扩容后表示的最高位是否1为所决定，由于移动的方向只有一个，即向高位移动。

### Spring

#### `BeanFactory`和`ApplicationContext`的区别

`BeanFactory`：是`Spring`里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能，`BeanFactory`启动时不会去实例化Bean，从容器中拿Bean的时候才会去实例化

`ApplicationContext`：应用上下文，继承了`BeanFactory`接口，是`Spring`中的一个更高级的容器，启动时实例化所有`Bean`，可以配置延迟加载来延迟实例化，提供了更多的功能

- 国际化
- 资源访问
- 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层
- 消息发送、响应机制（ApplicationEventPublisher）
- AOP（拦截器）

#### Spring、SpringMVC、SprinBoot区别

#### `SpringBoot`自动装配原理

`SpringBoot`所有自动配置类都是在启动的时候进行扫描并加载，通过`spring.factories`可以找到自动配置类的路径，但是不是所有存在于`spring,factories`中的配置都进行加载，而是通过`@ConditionalOnClass`注解进行判断条件是否成立（只要导入相应的stater，条件就能成立），如果条件成立则加载配置类，否则不加载该配置类。

- `SpringBoot`在启动的时候从类路径下的`META-INF/spring.factories`中获取`EnableAutoConfiguration`指定的值
- 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；
- 以前我们需要自己配置的东西 ， 自动配置类都帮我们解决了
- 整个`J2EE`的整体解决方案和自动配置都在`springboot-autoconfigure`的jar包中；
- 它将所有需要导入的组件以全类名的方式返回 ， 这些组件就会被添加到容器中 ；
- 它会给容器中导入非常多的自动配置类 `xxxAutoConfiguration`, 就是给容器中导入这个场景需要的所有组件 ，并配置好这些组件 ；
- 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；

#### SpringMVC的工作流程

1. 用户发送请求至前端控制器`DispatcherServlet`
2. `DispatcherServlet`收到请求调用处理器映射器`HandlerMapping`。
3. 处理器映射器根据请求`url`找到具体的处理器，生成处理器执行链`HandlerExecutionChain`(包括处理器对象和处理器拦截器)一并返回给`DispatcherServlet`。
4. `DispatcherServlet`根据处理器`Handler`获取处理器适配器`HandlerAdapter`执行`HandlerAdapter`处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作
5. 执行处理器`Handler`(`Controller`，也叫页面控制器)。
6. `Handler`执行完成返回`ModelAndView`
7. `HandlerAdapter`将`Handler`执行结果`ModelAndView`返回到`DispatcherServlet`
8. `DispatcherServlet`将`ModelAndView`传给`ViewReslover`视图解析器
9. `ViewReslover`解析后返回具体`View`
10. `DispatcherServlet`对`View`进行渲染视图（即将模型数据`model`填充至视图中）。
11. `DispatcherServlet`响应用户。

#### `SpringMVC`九大内置组件

1. `HandlerMapping(`处理器映射器)

   寻找Handler(注解/配置文件/接口)

2. `HandlerAdapter`(处理器适配器)

   处理找到的`Handler`,因为`Handler`的实现多种多样,所以对于`Handler`不同的内部结构需要进行一定的处理容器在初始化的时候会自动帮我们注入 (也可以自己配置)`RequestMappingHandlerAdapter` `HttpRequestHandlerAdapter` 和`SimpleControllerHandlerAdapter`这三个配置器。

3. `HandlerExceptionResolver`(异常处理器)

   当我们在寻找和处理Handler时难免会出现一些问题(异常),这个时候就需要一个专门来处理异常的角色

4. `ViewResolver`(视图解析器)

   用来渲染页面的,而`ViewResolver`所要做的就是找到渲染所用的模板和技术(页面类型)

5. `RequestToViewNameTranslator`(视图名称翻译器)

   当没有`ViewName`时,从请求中解析获取视图名

6. `LocaleResolver`(当前环境处理器)

   协助view的解析

   - 一是ViewResolver视图解析的时候；
   - 二是用到国际化资源或者主题的时候。

7. `ThemeResolver`(主题处理器)

   主题处理器用于解析主题,相当于解析系统的整体样式和风格.

8. `MultipartResolver`(文件处理器)

   用于处理上传请求。处理方法是将普通的`request`包装成`MultipartHttpServletRequest`，后者可以直接调用`getFile`方法获取File，如果上传多个文件，还可以调用`getFileMap`得到`FileName->File`结构的`Map`。此组件中一共有三个方法，作用分别是判断是不是上传请求，将`equest`包装成`MultipartHttpServletRequest`、处理完后清理上传过程中产生的临时资源。

9. `FlashMapManager`(参数传递管理器)

   请求重定向是的参数管理

#### `Spring`的核心

`IOC(Inverse of Control 控制反转)`：传统的`java`开发模式中，当需要一个对象时我们，我们会自己使用`new`或者`getInstance`等直接或者间接调用构造方法创建一个对象，而在Spring开发模式中，Spring容器使用了工厂模式为我们创建了所需要的对象，我们使用时不需要自己去创建，直接调用Spring为我们提供的对象即可，这就是控制反转的思想。实例化一个`java`对象有三种方式：使用类构造器，使用静态工厂方法，使用实例工厂方法，当使用spring时我们就不需要关心通过何种方式实例化一个对象，spring通过控制反转机制自动为我们实例化一个对象。

`AOP(Aspect Oriented Programming 面向切面编程)`：在面向对象编程(OOP)思想中，我们将事物纵向抽象成一个个的对象。而在面向切面编程中，我们将一个个对象某些类似的方面横向抽象成一个切面，对这个切面进行一些如权限验证，事物管理，记录日志等公用操作处理的过程就是面向切面编程的思想。

#### Spring的事务传播机制

一个事务方法运行在一个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新事务。

Spring支持7钟传播属性

- `Propagation.REQUIRED（required）`：支持当前事务，如果当前有事务， 那么加入事务， 如果当前没有事务则新建一个(默认情况)
- `Propagation.NOT_SUPPORTED（not_supported) `： 以非事务方式执行操作，如果当前存在事务就把当前事务挂起，执行完后恢复事务（忽略当前事务）；
- `Propagation.SUPPORTS (supports) `：如果当前有事务则加入，如果没有则不用事务。
- `Propagation.MANDATORY (mandatory) `：支持当前事务，如果当前没有事务，则抛出异常。（当前必须有事务）
- `PROPAGATION_NEVER (never)` ：以非事务方式执行，如果当前存在事务，则抛出异常。（当前必须不能有事务）
- `Propagation.REQUIRES_NEW (requires_new) `：支持当前事务，如果当前有事务，则挂起当前事务，然后新创建一个事务，如果当前没有事务，则自己创建一个事务。
- `Propagation.NESTED (nested 嵌套事务) ` ：如果当前存在事务，则嵌套在当前事务中。如果当前没有事务，则新建一个事务自己执行（和required一样）。嵌套的事务使用保存点作为回滚点，当内部事务回滚时不会影响外部事物的提交；但是外部回滚会把内部事务一起回滚回去。（这个和新建一个事务的区别）

#### Spring中单例bean是否线程安全

有状态的bean：对象中有实例变量（成员变量），可以保存数据，是非线程安全的

无状态的bean：对象中没有实例变量（成员变量），不能保存数据，可以在多线程环境下共享，是线程安全的

在`spring`中，绝大部分bean都是无状态的，因此即使这些bean默认是单例的，也不会出现线程安全问题的。比如`controller`、`service`、`dao`这些类，这些类里面通常不会含有成员变量，因此它们被设计成单例的。如果这些类中定义了实例变量，就线程不安全了，所以尽量避免定义实例变量。
对于`spring`中有状态的bean，比如`RequestContextHolder`、`TransactionSynchronizationManager`、`LocaleContextHolder`，为什么也能够设计成单例的呢？它是怎么保证线程安全的？
对于有状态的bean，`spring`采用`ThreadLocal`进行处理，使它们成为线程安全可以共享的对象

#### Spring中使用了哪些设计模式及应用场景

- 工厂方法：实现`FactoryBean`接口
- 单例模式：`Spring`依赖注入Bean实例默认单例
- 适配器模式：`SpringMVC`中的适配器`HandlerAdatper`
- 装饰器模式：`Spring`中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。
- 代理模式：`AOP`底层，使用动态代理实现
- 观察者模式：spring的事件驱动模型使用的是观察者模式，Spring中Observer模式常用的地方是listener的实现。
- 模版方法：父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现 

#### Spring事务的隔离级别有哪些

1. `DEFAULT` （默认） 

   这是一个`PlatfromTransactionManager`默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与`JDBC`的隔离级别相对。

2. `READ_UNCOMMITTED `（读未提交）

3. `READ_COMMITTED `（读已提交）

4. `REPEATABLE_READ `（可重复读）

5. `SERIALIZABLE`（串行化）

#### Spring事务的实现原理

#### Spring事务什么时候会失效

#### Spring是如何简化开发的

1. 基于POJO的轻量级和最小侵入性编程；
2. 通过依赖注入（DI）和面向接口实现松耦合；
3. 基于切面和惯例进行切面式编程；
4. 通过切面和模板减少样本式代码；

#### Spring支持的bean作用域有哪些

1. `singleton`作用域
2. `prototype`作用域
3. `request`作用域
4. `session`作用域
5. `global session`作用域

#### 简述Spring Bean的生命周期

1. Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化
2. Bean实例化后对将Bean的引入和值注入到Bean的属性中
3. 如果Bean实现了`BeanNameAware`接口的话，Spring将Bean的Id传递给`setBeanName()`方法
4. 如果Bean实现了`BeanFactoryAware`接口的话，Spring将调用`setBeanFactory()`方法，将`BeanFactory`容器实例传入
5. 如果Bean实现了`ApplicationContextAware`接口的话，Spring将调用Bean的`setApplicationContext()`方法，将bean所在应用上下文引用传入进来。
6. 如果Bean实现了`BeanPostProcessor`接口，Spring就将调用他们的`postProcessBeforeInitialization()`方法。
7. 如果Bean 实现了`InitializingBean`接口，Spring将调用他们的`afterPropertiesSet()`方法。类似的，如果bean使用`init-method`声明了初始化方法，该方法也会被调用
8. 如果Bean 实现了`BeanPostProcessor`接口，Spring就将调用他们的`postProcessAfterInitialization()`方法。
9. 此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。
10. 如果bean实现了`DisposableBean`接口，Spring将调用它的`destory()`接口方法，同样，如果bean使用了`destory-method `声明销毁方法，该方法也会被调用。

#### 如何理解Spring的starter

#### 如何实现一个`IOC`容器

1. 配置配置文件，定义bean信息
2. 加载配置文件，将读取到的bean信息封装`BeanDefination`
3. 根据`BeanDefination`反射生成Bean
4. 对Bean进行依赖注入

#### 什么是自动装配，它有哪些方式

Spring可以通过`@AutoWired`或者`xml`方式自动注入我们需要的依赖

#### 使用Spring的优势

1. 通过`IOC`容器和依赖注入，大大降低了代码的耦合和侵入性
2. 支持`AOP`编程
3. 支持声明式事务
4. 方便集成各种优秀框架
5. 对`Java EE`开发中的一些`API`提供了封装，降低了应用难度
6. 非侵入式减少应用程序对框架的依赖

#### 说说你对`AOP`的理解

一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。

#### 说说你对`IOC`的理解

`Ioc—Inversion of Control`，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，`Ioc`意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。

#### 说说你对Spring的理解

是一个开源的`Java/JavaEE`全功能栈的应用程序，`SpringFramework`提供了一个简易的开发方式，这种开发方式可以避免使用写可能使底层代码变得繁杂混乱的大量的属性文件和不帮助类。它包含多个模块，比如`Data Acess`、`web`、`AOP`、`Core`、`Test`等等。其中最主要的是支持了依赖注入和`AOP`编程。

#### SpringCloud的核心组件有哪些，分别有什么作用

1. Eureka：服务的注册与发现
2. Feign：基于动态代理和HTTP的远程调用
3. Ribbon：实现负载均衡
4. Hystrix：服务降级、熔断
5. gateway：网关路由，提供路由、鉴权、监控、限流、缓存等功能

#### 微服务架构的原理是什么

**概念：** 把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。

**定义：** 围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。

**本质：** 用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题。

#### 注册中心的原理是什么

1. 各个微服务启动时，将自己的网络地址，服务名称等信息注册到注册中心，注册中心存储这些数据
2. 服务消费者从注册中心查询服务提供者的地址，并通过获取的地址调用服务
3. 各个微服务与注册中心通过一定的机制（例如心跳）通信，如果注册中心与某个微服务长时间无法通信，就会下线该实例

#### 配置中心是什么

在服务运行之前，将所需配置从配置仓库拉取到本地服务，达到统一化配置管理，方便集群扩容

#### 配置中心是如何实现自动刷新的

#### 用zookeeper和Eureka做注册中心有什么区别

**Zookeeper 保证 CP**

> Zookeeper 是保证数据的一致性的，但是并不是强一致的。
>
> 比如客户端 A 提交一个写操作，Zookeeper 在过半数节点操作成功之后就可以返回，但此时，客户端 B 的读操作请求的是 A 写操作尚未同步到的节点，那么读取的就不是 A 最新提交的数据了。我们可以在读取数据的时候先执行一下 sync 操作，即与 leader 节点先同步一下数据，再去取，这样才能保证数据的强一致性。
>
> 关于可用性，Zookeeper 的 master 节点因为网络故障与其他节点失去联系时，剩余节点会重新进行 leader 选举，选举  leader 的时间太长，需要 30 ~ 120 s, 且选举期间整个 Zookeeper  集群都是不可用的，这就导致在选举期间注册服务瘫痪。同时，在云部署的环境下，因网络问题使得 Zookeeper 集群失去 master  节点是较大概率会发生的事，整个服务停下这么长的时间是非常严重的，比如双十一。

**Eureka 保证 AP**

> 就是针对 Zookeeper 出现的这一问题，Eureka选择了优先保证可用性。
>
> 大规模网络部署时，失败是在所难免的。当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接  down 掉不可用。而集群部署的 Eureka  即使挂掉一定的数量，也可以保证有信息可以返回，依然可以提供注册和查询服务，只不过查到的信息可能不是最新的。

#### `SpringCloud`和`Dubbo`有哪些区别

1. dubbo由于是二进制的传输，占用带宽会更少
2. springCloud是http协议传输，带宽会比较多，同时使用http协议一般会使用JSON报文，消耗会更大
3. dubbo的开发难度较大，原因是dubbo的jar包依赖问题很多大型工程无法解决
4. springcloud的接口协议约定比较自由且松散，需要有强有力的行政措施来限制接口无序升级
5. dubbo的注册中心可以选择zk,redis等，springcloud的注册中心用eureka或者Consul

#### Ribbon负载均衡原理是什么

#### 微服务熔断降级机制是什么

#### ZAB协议是什么

#### 注册中心挂了，或者服务挂了，应该如何处理

### MySQL

#### MVCC解决的问题是什么

#### MVCC实现原理是什么

#### 事务的基本要素

1. 原子性：事务开始后，要么全部完成，要么全部放弃，是不可分割的整体
2. 一致性：事务开始结束后，数据库的完整性约束没有被破坏
3. 隔离性：同一时间，只能有一个事务请求数据，不同事务之间彼此没有任何干扰
4. 持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚

#### `Mysql`的隔离级别有哪些

1. 读取未提交，可能产生脏读、不可重复读、幻读
2. 读取已提交，可能产生不可重复读、幻读
3. 可重复读，可能产生幻读
4. 串行化

#### `Mysql`复制的原理是什么

1. Master记录二进制日志， 每次提交事务完成数据更新前，Master将数据更新的时间记录到二进制日志中，`MySql`会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志。再记录二进制日志后，主库会告诉存储引擎可以提交事务了。
2. Slave将Master的二进制日志复制到本地的中继日志中，首先，Slave会启动一个工作线程，成为I/O线程，  I/O线程跟Master建立一个普通的客户端链接，然后再Master上启动一个特殊的二进制转储（binlog  dump）线程（该线程没有对应的SQL命令），这个二进制转储线程会读取主库上的二进制日志中的事件。从库I/O线程将接受到时间记录到中继日志中。
3. 从库的SQL线程执行最后异步，该线程的从中继日志中读取事件并在从库执行，从而实现从库数据更新。

#### Mysql聚簇索引和非聚簇索引的区别

都是B+树的数据结构

- 聚簇索引：将数据存储和索引放在一起、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻的存放在磁盘上的。
- 非聚簇索引：叶子节点不存储数据，存储的是数据行地址，也就是说根据索引查找到数据行的位置再去磁盘查找数据，这就有点类似一本书的目录，比如要找到第三章第一节，那就现在目录里面查找，找到对应的页码后再去对应的页码看文章。

优势

- 查找通过聚簇索引可以直接获取到数据，相比非聚簇索引需要第二次查询(覆盖索引除外)效率要高
- 聚簇索引对范围查询的效率很高，因为其数据是按照大小排列的
- 聚簇索引适合用在排序场合，非聚簇索引不适合。

劣势

- 维护索引代价大，特别是插入新行或者主键被更新导致要分页的时候。建议在大量插入新行后，选择负载较低的时间段，通过OPTIMIZE TABLE优化表
- 表因为使用UUID作为主键，使数据存储稀疏，这就会出现聚簇索引有可能会比全表扫面更慢，所以建议使用int的auto_increment作为主键。
- 如果主键比较大的话，那辅助索引将会变得更大，因为辅助索引的叶子节点存储的是主键值，过长的主键值，会导致非叶子节点占用更多的物理空间

#### `Mysql`索引的基本原理

#### `MySQL`索引有哪些结构，各自优劣是什么

#### `MySQL`锁的类型有哪些

#### `MySQL`为什需要主从同步

#### `MySQL`执行计划怎么看

#### 简述`MyISAM`和`InnoDB`的区别

1. `InnoDB`支持事务，`MyISAM`不支持事务。这是`MySQL`将默认存储引擎从`MyISAM`变成`InnoDB`的重要原因之一；
2. `InnoDB`支持外键，而`MyISAM`不支持。对一个包含外键的`InnoDB`表转为`MYISAM`会失败；
3. `InnoDB`是聚集索引，`MyISAM`是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此`InnoDB`必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而`MyISAM`是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
4. `InnoDB`不保存表的具体行数，执行`select count(*) from table`时需要全表扫描。而`MyISAM`用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快
5. `InnoDB`最小的锁粒度是行锁，`MyISAM`最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 `MySQL`将默认存储引擎从`MyISAM`变成`InnoDB`的重要原因之一

#### 简述MySQL中索引类型有哪些，以及对数据库的性能影响

物理角度

1. 聚簇索引
2. 非聚簇索引

从逻辑角度

1. 主键索引：主键索引是一种特殊的唯一索引，不允许有空值
2. 普通索引或者单列索引
3. 多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合
4. 唯一索引或者非唯一索引

#### 如何处理`MySQL`的慢查询

1. EXPLAIN

   做`MySQL`优化，我们要善用`EXPLAIN`查看`SQL`执行计划。

   - type列，连接类型。一个好的SQL语句至少要达到range级别。杜绝出现all级别。
   - key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式。
   - key_len列，索引长度。
   - rows列，扫描行数。该值是个预估值。
   - extra列，详细说明。注意，常见的不太友好的值，如下：Using filesort，Using temporary。

2. `SQL`语句中IN包含的值不应过多

   `MySQL`对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：`select id from t where num in(1,2,3) `对于连续的数值，能用`between`就不要用`in`了；再或者使用连接来替换。

3. SELECT语句务必指明字段名称

   `SELECT*`增加很多不必要的消耗（CPU、IO、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在`select`后面接上字段名。

4. 当只需要一条数据的时候，使用`limit 1`

5. 如果排序字段没有用到索引，就尽量少排序

6. 如果限制条件中其他字段没有索引，尽量少用or

   or两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用union all或者是union（必要的时候）的方式来代替“or”会得到更好的效果。

7. 尽量用union all代替union

   union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重复数据。

8. 区分in和exists、not in和not exists

   区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。

9. 分段查询

   在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。

10. 避免在where子句中对字段进行null值判断

    对于null的判断会导致引擎放弃使用索引而进行全表扫描。

11. 不建议使用%前缀模糊查询

12. 避免在where子句中对字段进行表达式操作

13. 对于联合索引来说，要遵守最左前缀法则

#### 什么是MVCC

#### 什么是`MySQL`主从复制

MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。可以实现读写分离，让主库负责写，从库负责读，使数据层能支持更大的并发

#### 索引的设计原则有哪些

1. 设置合理的索引，否则不仅会占用大量的磁盘空间，而且还会影响`INSERT、DELETE、UPDATE`等语句的性能
2. 避免对经常更新的表进行过多的索引，并且索引中的列尽可能少。而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段。
3. 据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。
4. 在条件表达式中经常用到的、不同值较多的列上建立索引，在不同值较少的列上不要建立索引。
5. 当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引能够确保定义的列的数据完整性，提供查询速度。
6. 在频繁进行排序和分组（GROUP BY或ORDER BY）的列上建立索引，如果排序的列有多个，可以在这些列上建立组合索引。

优化原则

1. 避免对列的操作。任何对列的操作都可能导致全表扫描，这里所谓的操作包括数据库函数、计算表达式等，查询时要尽可能将操作移至等式的右边，甚至去掉函数。
2. 避免不必要的类型转换
3. 增加查询的范围限制，避免全范围的查询
4. 尽量去掉`IN`、`OR`，使用`between`和`union`代替
5. 尽量去掉 <>
6. 去掉WHERE字句中的IS NULL和IS NOT NULL。WHERE字句中的IS NULL和IS NOT NULL将不会使用索引而是进行全表搜索。
7. LIKE字句尽量前段匹配

### Redis

#### redis持久化rdb和aof

#### redis单线程为什么这么快，有哪些线程模型

#### `redis`的过期键有哪些删除策略

**对于过期键一般有三种策略**

- 定时删除：在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作；
- 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；
- 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。

**`Redis`的过期键删除策略**：

1. 惰性删除
2. 定期删除

#### `redis`缓存如何回收

设置了`redis`的最大内存占用（`maxmemory`）后，当最大内存占用限制达到时，`redis`会使用缓存回收策略

1. `volatile-lru` -> 根据`LRU`算法删除设置了超时属性（expire）的键，直到腾出足够空间为止。如果没有可删除的键对象，回退到`noeviction`策略。
2. `allkeys-lru` -> 根据`LRU`算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。
3. `volatile-lfu` -> 根据`LFU`算法删除设置了超时属性（expire）的键，直到腾出足够空间为止。如果没有可删除的键对象，回退到`noeviction`策略。
4. `allkeys-lfu` -> 根据`LFU`算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。
5. `volatile-random` -> 随机删除过期键，直到腾出足够空间为止。
6. `allkeys-random` -> 随机删除所有键，直到腾出足够空间为止。
7. `volatile-ttl` -> 根据键值对象的`ttl`属性，删除最近将要过期数据。如果没有，回退到`noeviction`策略。
8. `noeviction` -> 不会删除任何数据，拒绝所有写入操作并返 回客户端错误信息，此 时`Redis`只响应读操作。

`LRU` (Least recently used) 最近最少使用，`LFU` (Least frequently used) 最不经常使用

#### `redis`集群有哪些方案

主从复制：

1. 主机自动将数据同步到从机，可以实现读写分离，分担主机压力。
2. 不具备自动容错和恢复功能，主从机宕机后需要手动重启或切换`IP`，主机宕机还有可能造成数据不一致问题。
3. `Redis`较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。

哨兵模式：

1. 哨兵模式基于主从复制，拥有它的所有有点，哨兵集群可以监视主从服务器，主服务器宕机后会自动选举从服务器代替
2. `Redis`较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。

`Redis-Cluster`集群：

`redis3.0`上加入了`cluster`模式，实现的`redis`的分布式存储，也就是说每台`redis`节点上存储不同的内容。

- 所有的`redis`节点彼此互联(`PING-PONG`机制),内部使用二进制协议优化传输速度和带宽。
- 节点的fail是通过集群中超过半数的节点检测失效时才生效。
- 客户端与`redis`节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。

在`redis`的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们的存取的key到达的时候，`redis`会根据`crc16`的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383  之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。

为了保证高可用，`redis-cluster`集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。

#### `redis`事务是如何实现的

`Redis`事务通常会使用`MULTI,EXEC,WATCH,DISCARD`等命令来完成,`redis`实现事务实现的机制与常见的关系型数据库有很大的区别,比如`redis`的事务不支持回滚,事务执行时会阻塞其它客户端的请求执行

事务由multi开启，将多个命令入队到事务中，最后exec命令触发事务

- **原子性**：对于`Redis`的事务功能来说，事务队列中的命令要么就全部执行，要么就一个都不执行，但是`Redis`的事务是不支持回滚操作的
- **一致性**：`Redis`通过谨慎的错误检测和简单的设计保证事务的一致性。`Redis`事务可能出错的地方以及解决方案：
  1. **入队错误**：如果一个事务在入队命令的过程中发现命令不存在或者命令格式不正确，`Redis`将拒绝执行这个事务
  2. **执行错误**：事务在执行的过程中发生错误的命令会被服务器识别出来，并进行相应的错误处理，所以这些出错的命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响
  3. **服务器停机**：如果`Redis`服务器在执行事务的过程中停机，且服务器运行在任意模式下（无持久化的内存模式、`RDB`模式或者`AOF`模式），事务执行中途发生的停机都不会影响数据库的一致性
- **隔离性**：`Redis`使用单线程的方式执行事务，并且服务器保证在执行事务期间不会对事务进行中断，因此，`Redis`的事务总是串行的方式运行，并且事务总是具有隔离性的
- **持久性**：当服务器运行在`AOF`持久化模式下，并且`appendfsync`选项的值是`always`时，事务是具有耐久性的，其他情况不具有耐久性

#### `redis`主从复制原理

**全量同步**
`Redis`全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： 

- 从服务器连接主服务器，发送SYNC命令； 
- 主服务器接收到SYNC命名后，开始执行`BGSAVE`命令生成`RDB`文件并使用缓冲区记录此后执行的所有写命令； 
- 主服务器`BGSAVE`执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；
- 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 
- 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 
- 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；

**增量同步**
`Redis`增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。

#### 缓存击穿、穿透、雪崩、预热解决方案

### zookeeper

#### zookeeper的watch机制是什么

#### zookeeper的命名、配置、管理是如何实现的

#### zookeeper的数据模型和节点类型

### kafka

#### 简述kafka架构设计

#### kafka的rebalance机制是什么

#### kafka是pull还是push，分析一下优劣

#### kafka消息丢失的场景有哪些

#### kafka中zookeeper作用是什么

#### kafka中高性能如何保障

### RabbitMq

#### rabbitmq的架构设计

#### rabbitmq的事务消息处理

#### rabbitmq如何保证消息的发送和接收

#### rabbitmq死信队列，延迟队列

### Mybatis

#### `Mybatis`的优缺点有哪些

`Mybatis`是一个半自动的`ORM`持久层框架，内部封装了`JDBC`。作为开发者只需要关注`sql`语句本身。`Mybatis`是通过`xml`或注解的方式将需要执行的各种`statement`配置起来。通过`Java`对象和`statement`中的`sql`动态参数映射生成最终执行的`sql`语句，最终由`Mabtais`框架执行`sql`并将结果映射为`Java`对象并返回。`MyBatis`支持定制化`SQL`、存储过程以及高级映射。`MyBatis`是可以双向映射的，可以将数据集映射为`Java`对象，也可以将`Java`对象映射为数据库中的记录。

优点：

- 简单易上手
- 消除了`JDBC`大量冗余代码
- 兼容各种数据库
- 提供很多第三方插件
- 和Spring集成性好
- `sql`和代码解耦
- 支持动态`sql`
- 支持对象与数据`ORM`字段关系映射

缺点：

- `sql`编写量大，要求一定`sql`功底
- `sql`依赖数据库，可移植性差，不能随意更换数据库

#### Mybatis和hibernate的区别

#### `Mybatis`中#{}和${}的区别

- `Mybatis`在处理#{}时，会将`sql`中的#{}替换为?号，调用`PreparedStatement`的 set 方法来赋值，使用#{}可以有效的防止`SQL`注入，提高系统安全性。
- `Mybatis`在处理${}时，使用的是字符串拼接

#### Mybatis插件的运行原理和开发流程

- 原理

  `JDK`动态代理+责任链设计模式
