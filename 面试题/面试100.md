#### 面向对象有哪些特征

- 封装：隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。
- 继承：是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。
- 多态：就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

#### `ArrayList`和`linkedList`有什么区别

- 数据结构不同：`ArrayList`底层使用Array（数组）实现，`LinkedList`底层使用链表实现
- `ArrayList`可以看做是一个能够自动增长的数组，扩容时按照当前容量1.5倍进行扩容

#### 高并发集合有哪些

- 早期线程安全集合

  `Vector`：类似于`ArrayList`，可变数组实现

  `HashTable`：类似于`HashMap`，但是它的key和value都不能为null

- `Collections`包装方法

  ```java
  List<E> synArrayList = Collections.synchronizedList(new ArrayList<E>());
  
  Set<E> synHashSet = Collections.synchronizedSet(new HashSet<E>());
  
  Map<K,V> synHashMap = Collections.synchronizedMap(new HashMap<K,V>());
  ```

  `Collections`针对每种集合都声明了一个线程安全的包装类，在原集合的基础上添加了锁对象，集合中的每个方法都通过这个锁对象实现同步

- `java.util.concurrent`包中的集合

  1. `ConcurrentHashMap`：

     `ConcurrentHashMap`和`HashTable`都是线程安全的集合，它们的不同主要是加锁粒度上的不同。`HashTable`的加锁方法是给每个方法加上synchronized关键字，这样锁住的是整个Table对象。而`ConcurrentHashMap`是更细粒度的加锁

     在`JDK1.8`之前，`ConcurrentHashMap`加的是分段锁，也就是`Segment`锁，每个`Segment`含有整个`table`的一部分，这样不同分段之间的并发操作就互不影响
     `JDK1.8`对此做了进一步的改进，它取消了`Segment`字段，直接在`table`元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率

  2. `CopyOnWriteArrayList`和`CopyOnWriteArraySet`

     它们是加了写锁的`ArrayList`和`ArraySet`，锁住的是整个对象，但读操作可以并发执行，`CopyOnWriteArraySet`底层使用`CopyOnWriteArrayList`实现

  3. 除此之外还有`ConcurrentSkipListMap`、`ConcurrentSkipListSet`、`ConcurrentLinkedQueue`、`ConcurrentLinkedDeque`等，至于为什么没有`ConcurrentArrayList`，原因是无法设计一个通用的而且可以规避`ArrayList`的并发瓶颈的线程安全的集合类，只能锁住整个`list`，这用`Collections`里的包装类就能办到

#### jdk8新特性

#### java中抽象类和接口有什么区别

- 构造方法：抽象类可以有构造方法，接口中不能有构造方法
- 成员变量：抽象类可以有普通成员变量，任意访问类型的的静态成员变量。接口中不能有普通成员变量，只能有`public static final`修饰的静态变量
- 方法：抽象类可以包含普通方法和抽象方法，接口中所有方法都是必须是抽象方法。抽象类中可以包含静态方法，接口中不能包含静态方法
- 访问类型：抽象类中方法可以是`public`、`protected`、默认，但是接口中的抽象方法只能是`public`，并且默认是`public abstract`类型
- 实现：抽象类单继承，接口可以多继承
- 应用上：抽象类主要用于抽象类别，接口主要用来抽象方法功能，当我们来抽象一个狗的对象时，可以使用抽象类来描述狗，具体到那种类型的狗时可以继承这个抽象类，当我们描述一类动作时，比如猫和狗都有跑这个能力，就可以实现接口来实现跑这个功能

#### `hashcode`和`equals`如何使用

自定义类中的的`equals`和==是一样的，比较的是内存地址，当重写`equals`方法时，必须也要同事重写`hashcode`方法，因为在比如`HashMap`中，比较两个对象是否相等，首先是调用`hashcode`来比较，再用`equals`比较，如果使用`equals`比较相同，那么比较`hashcode`时也必须相同

#### `java`代理的几种实现方式

- 静态代理：自己手动实现
- 动态代理：
  1. `JDK`动态代理，代理类必须实现接口
  2. `CGLIB`动态代理，代理类可以不用实现接口

#### ==和`equals`有哪些区别

`Object`类中，`equals`用==实现，对象都是比较内存地址，基本数据类型比较值，但是可以重写`equals`方法来实现内容比较，比如`String`中`equals`方法就是重写过的。

#### `java`异常处理机制是什么

处理机制为：抛出异常，捕捉异常

抛出异常的方法：`throws`和`throw`：

- `throws`：通常用在声明方法时，用来指定方法可能抛出的异常，多个异常使用逗号分隔，`throws`关键字将异常抛给上一级，如果不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的代码。

- `throw`：通常用在方法体中或者用来抛出用户自定义异常，并且抛出一个异常对象。程序在执行到throw语句时立即停止，如果要捕捉`throw`抛出的异常，则必须使用`try-catch`语句块或者`try-catch-finally`语句。

  `try-catch-finally`语句：首先执行`try`中代码，如果代码执行正常就就继续执行`finally`代码块，如果发生异常且被`catch`捕获到就执行`catch`代码块，然后执行`finally`代码块。

#### `java`中重写和重载的区别

重写：实质是子类对父类的函数进行了重定义。若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法，如需父类中原有的方法则可使用 super 关键字。重写方法访问修饰符不能小于被重写方法，抛出的异常必须是被重写方法抛出异常或者其子异常

重载：是让类以统一的方式处理不同类型数据的一种手段，实质表现就是多个具有不同的参数个数或者类型的同名函数（返回值类型可随意，不能以返回类型作为重载函数的区分标准）同时存在于同一个类中，是一个类中多态性的一种表现，调用时通过参数判断具体方法。

重载与重写是 `Java 多态性`的不同表现。

- 重写是父类与子类之间多态性的表现，在运行时起作用（动态多态性，譬如实现动态绑定）
- 而重载是一个类中多态性的表现，在编译时起作用（静态多态性，譬如实现静态绑定）。

#### `String`、`StringBuffer`、`StringBuilder`区别和使用场景

`String`：字符数组被final修饰，不可变，如果进行字符串操作是新建一个`String`。

`StringBuffer`：可变字符串，线程安全，适用于多线程环境操作字符串

`StringBuilder`：可变字符串，线程不安全，适用于单线程环境操作字符串，

#### 怎么声明一个类不会被继承

- 使用`final`修饰类
- 私有化构造器

#### `BeanFactory`和`ApplicationContext`的区别

`BeanFactory`：是`Spring`里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能，`BeanFactory`启动时不会去实例化Bean，从容器中拿Bean的时候才会去实例化

`ApplicationContext`：应用上下文，继承了`BeanFactory`接口，是`Spring`中的一个更高级的容器，启动时实例化所有`Bean`，可以配置延迟加载来延迟实例化，提供了更多的功能

- 国际化
- 资源访问
- 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层
- 消息发送、响应机制（ApplicationEventPublisher）
- AOP（拦截器）

#### `HashMap`和`HashTable`的区别

线程安全不同：

- `Hashtable`的几乎所有函数都是同步的，即它是线程安全的，支持多线程。
- `HashMap`的函数则是非同步的，它不是线程安全的。

对null值的处理不同：

- `HashMap`的key、value都可以为null。
- `Hashtable`的key、value都不可以为null。

容量的初始值 和 增加方式都不一样：

- `HashMap`默认的容量大小是16；增加容量时，每次将容量变为“原始容量x2”。
- `Hashtable`默认的容量大小是11；增加容量时，每次将容量变为“原始容量x2 + 1”。

添加key-value时的hash值算法不同

- `HashMap`添加元素时，是使用自定义的哈希算法。
- `Hashtable`没有自定义哈希算法，而直接采用的key的hashCode()。

#### `HashMap`有哪些线程安全的方式

- 使用`Collections.synchronizedMap(new HashMap<String, Strinig>())`获取线程安全`Map`
- 使用`ConcurrentHashMap`

#### `HashMap`在扩容上做了哪些优化

`JDK7`

- `HashMap`的内部数据保存的都是链表。因此逻辑相对简单：在准备好新的数组后，map会遍历数组的每个“桶”，然后遍历桶中的每个Entity，重新计算其hash值（也有可能不计算），找到新数组中的对应位置，以头插法插入新的链表。

`JDK8`扩容

1. 空参数的构造函数：实例化的`HashMap`默认内部数组是null，即没有实例化。第一次调用put方法时，则会开始第一次初始化扩容，长度为16。
2. 有参构造函数：用于指定容量。会根据指定的正整数找到不小于指定容量的2的幂数，将这个数设置赋值给**阈值**（threshold）。第一次调用put方法时，会将阈值赋值给容量，然后让 阈值=容量*负载因子（因此并不是我们手动指定了容量就一定不会触发扩容，超过阈值后一样会扩容！！)
3. 如果不是第一次扩容，则容量变为原来的2倍，阈值也变为原来的2倍。*（容量和阈值都变为原来的2倍时，负载因子还是不变）*

`JDK8`性能有了大大的提升：由于数组的容量是以2的幂次方扩容的，那么一个Entity在扩容时，新的位置要么在原位置，要么在原长度+原位置的位置。数组长度变为原来的2倍，表现在二进制上就是多了一个高位参与数组下标确定。此时，一个元素通过hash转换坐标的方法计算后，恰好出现一个现象：最高位是0则坐标不变，最高位是1则坐标变为“10000+原坐标”，即“原长度+原坐标”。

#### MVCC解决的问题是什么

#### MVCC实现原理是什么

#### `Mybatis`的优缺点有哪些

`Mybatis`是一个半自动的`ORM`持久层框架，内部封装了`JDBC`。作为开发者只需要关注`sql`语句本身。`Mybatis`是通过`xml`或注解的方式将需要执行的各种`statement`配置起来。通过`Java`对象和`statement`中的`sql`动态参数映射生成最终执行的`sql`语句，最终由`Mabtais`框架执行`sql`并将结果映射为`Java`对象并返回。`MyBatis`支持定制化`SQL`、存储过程以及高级映射。`MyBatis`是可以双向映射的，可以将数据集映射为`Java`对象，也可以将`Java`对象映射为数据库中的记录。

优点：

- 简单易上手
- 消除了`JDBC`大量冗余代码
- 兼容各种数据库
- 提供很多第三方插件
- 和Spring集成性好
- `sql`和代码解耦
- 支持动态`sql`
- 支持对象与数据`ORM`字段关系映射

缺点：

- `sql`编写量大，要求一定`sql`功底
- `sql`依赖数据库，可移植性差，不能随意更换数据库

#### Mybatis和hibernate的区别

#### `Mybatis`中#{}和${}的区别

- `Mybatis`在处理#{}时，会将`sql`中的#{}替换为?号，调用`PreparedStatement`的 set 方法来赋值，使用#{}可以有效的防止`SQL`注入，提高系统安全性。
- `Mybatis`在处理${}时，使用的是字符串拼接

#### Mybatis插件的运行原理和开发流程

- 原理

  `JDK`动态代理+责任链设计模式

#### 事务的基本要素

1. 原子性：事务开始后，要么全部完成，要么全部放弃，是不可分割的整体
2. 一致性：事务开始结束后，数据库的完整性约束没有被破坏
3. 隔离性：同一时间，只能有一个事务请求数据，不同事务之间彼此没有任何干扰
4. 持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚

#### `Mysql`的隔离级别有哪些

1. 读取未提交，可能产生脏读、不可重复读、幻读
2. 读取已提交，可能产生不可重复读、幻读
3. 可重复读，可能产生幻读
4. 串行化

#### `Mysql`复制的原理是什么

1. Master记录二进制日志， 每次提交事务完成数据更新前，Master将数据更新的时间记录到二进制日志中，`MySql`会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志。再记录二进制日志后，主库会告诉存储引擎可以提交事务了。
2. Slave将Master的二进制日志复制到本地的中继日志中，首先，Slave会启动一个工作线程，成为I/O线程，  I/O线程跟Master建立一个普通的客户端链接，然后再Master上启动一个特殊的二进制转储（binlog  dump）线程（该线程没有对应的SQL命令），这个二进制转储线程会读取主库上的二进制日志中的事件。从库I/O线程将接受到时间记录到中继日志中。
3. 从库的SQL线程执行最后异步，该线程的从中继日志中读取事件并在从库执行，从而实现从库数据更新。

#### Mysql聚簇索引和非聚簇索引的区别

都是B+树的数据结构

- 聚簇索引：将数据存储和索引放在一起、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻的存放在磁盘上的。
- 非聚簇索引：叶子节点不存储数据，存储的是数据行地址，也就是说根据索引查找到数据行的位置再去磁盘查找数据，这就有点类似一本书的目录，比如要找到第三章第一节，那就现在目录里面查找，找到对应的页码后再去对应的页码看文章。

优势

- 查找通过聚簇索引可以直接获取到数据，相比非聚簇索引需要第二次查询(覆盖索引除外)效率要高
- 聚簇索引对范围查询的效率很高，因为其数据是按照大小排列的
- 聚簇索引适合用在排序场合，非聚簇索引不适合。

劣势

- 维护索引代价大，特别是插入新行或者主键被更新导致要分页的时候。建议在大量插入新行后，选择负载较低的时间段，通过OPTIMIZE TABLE优化表
- 表因为使用UUID作为主键，使数据存储稀疏，这就会出现聚簇索引有可能会比全表扫面更慢，所以建议使用int的auto_increment作为主键。
- 如果主键比较大的话，那辅助索引将会变得更大，因为辅助索引的叶子节点存储的是主键值，过长的主键值，会导致非叶子节点占用更多的物理空间

#### `Mysql`索引的基本原理

#### `MySQL`索引有哪些结构，各自优劣是什么

#### `MySQL`锁的类型有哪些

#### `MySQL`为什需要主从同步

#### `MySQL`执行计划怎么看

#### Spring、SpringMVC、SprinBoot区别

#### `SpringBoot`自动装配原理

`SpringBoot`所有自动配置类都是在启动的时候进行扫描并加载，通过`spring.factories`可以找到自动配置类的路径，但是不是所有存在于`spring,factories`中的配置都进行加载，而是通过`@ConditionalOnClass`注解进行判断条件是否成立（只要导入相应的stater，条件就能成立），如果条件成立则加载配置类，否则不加载该配置类。

- `SpringBoot`在启动的时候从类路径下的`META-INF/spring.factories`中获取`EnableAutoConfiguration`指定的值
- 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；
- 以前我们需要自己配置的东西 ， 自动配置类都帮我们解决了
- 整个`J2EE`的整体解决方案和自动配置都在`springboot-autoconfigure`的jar包中；
- 它将所有需要导入的组件以全类名的方式返回 ， 这些组件就会被添加到容器中 ；
- 它会给容器中导入非常多的自动配置类 `xxxAutoConfiguration`, 就是给容器中导入这个场景需要的所有组件 ，并配置好这些组件 ；
- 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；

#### SpringMVC的工作流程

1. 用户发送请求至前端控制器`DispatcherServlet`
2. `DispatcherServlet`收到请求调用处理器映射器`HandlerMapping`。
3. 处理器映射器根据请求`url`找到具体的处理器，生成处理器执行链`HandlerExecutionChain`(包括处理器对象和处理器拦截器)一并返回给`DispatcherServlet`。
4. `DispatcherServlet`根据处理器`Handler`获取处理器适配器`HandlerAdapter`执行`HandlerAdapter`处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作
5. 执行处理器`Handler`(`Controller`，也叫页面控制器)。
6. `Handler`执行完成返回`ModelAndView`
7. `HandlerAdapter`将`Handler`执行结果`ModelAndView`返回到`DispatcherServlet`
8. `DispatcherServlet`将`ModelAndView`传给`ViewReslover`视图解析器
9. `ViewReslover`解析后返回具体`View`
10. `DispatcherServlet`对`View`进行渲染视图（即将模型数据`model`填充至视图中）。
11. `DispatcherServlet`响应用户。

#### `SpringMVC`九大内置组件

1. `HandlerMapping(`处理器映射器)

   寻找Handler(注解/配置文件/接口)

2. `HandlerAdapter`(处理器适配器)

   处理找到的`Handler`,因为`Handler`的实现多种多样,所以对于`Handler`不同的内部结构需要进行一定的处理容器在初始化的时候会自动帮我们注入 (也可以自己配置)`RequestMappingHandlerAdapter` `HttpRequestHandlerAdapter` 和`SimpleControllerHandlerAdapter`这三个配置器。

3. `HandlerExceptionResolver`(异常处理器)

   当我们在寻找和处理Handler时难免会出现一些问题(异常),这个时候就需要一个专门来处理异常的角色

4. `ViewResolver`(视图解析器)

   用来渲染页面的,而`ViewResolver`所要做的就是找到渲染所用的模板和技术(页面类型)

5. `RequestToViewNameTranslator`(视图名称翻译器)

   当没有`ViewName`时,从请求中解析获取视图名

6. `LocaleResolver`(当前环境处理器)

   协助view的解析

   - 一是ViewResolver视图解析的时候；
   - 二是用到国际化资源或者主题的时候。

7. `ThemeResolver`(主题处理器)

   主题处理器用于解析主题,相当于解析系统的整体样式和风格.

8. `MultipartResolver`(文件处理器)

   用于处理上传请求。处理方法是将普通的`request`包装成`MultipartHttpServletRequest`，后者可以直接调用`getFile`方法获取File，如果上传多个文件，还可以调用`getFileMap`得到`FileName->File`结构的`Map`。此组件中一共有三个方法，作用分别是判断是不是上传请求，将`equest`包装成`MultipartHttpServletRequest`、处理完后清理上传过程中产生的临时资源。

9. `FlashMapManager`(参数传递管理器)

   请求重定向是的参数管理

#### `Spring`的核心

`IOC(Inverse of Control 控制反转)`：传统的`java`开发模式中，当需要一个对象时我们，我们会自己使用`new`或者`getInstance`等直接或者间接调用构造方法创建一个对象，而在Spring开发模式中，Spring容器使用了工厂模式为我们创建了所需要的对象，我们使用时不需要自己去创建，直接调用Spring为我们提供的对象即可，这就是控制反转的思想。实例化一个`java`对象有三种方式：使用类构造器，使用静态工厂方法，使用实例工厂方法，当使用spring时我们就不需要关心通过何种方式实例化一个对象，spring通过控制反转机制自动为我们实例化一个对象。

`AOP(Aspect Oriented Programming 面向切面编程)`：在面向对象编程(OOP)思想中，我们将事物纵向抽象成一个个的对象。而在面向切面编程中，我们将一个个对象某些类似的方面横向抽象成一个切面，对这个切面进行一些如权限验证，事物管理，记录日志等公用操作处理的过程就是面向切面编程的思想。

#### Spring的事务传播机制

一个事务方法运行在一个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新事务。

Spring支持7钟传播属性

- `Propagation.REQUIRED（required）`：支持当前事务，如果当前有事务， 那么加入事务， 如果当前没有事务则新建一个(默认情况)
- `Propagation.NOT_SUPPORTED（not_supported) `： 以非事务方式执行操作，如果当前存在事务就把当前事务挂起，执行完后恢复事务（忽略当前事务）；
- `Propagation.SUPPORTS (supports) `：如果当前有事务则加入，如果没有则不用事务。
- `Propagation.MANDATORY (mandatory) `：支持当前事务，如果当前没有事务，则抛出异常。（当前必须有事务）
- `PROPAGATION_NEVER (never)` ：以非事务方式执行，如果当前存在事务，则抛出异常。（当前必须不能有事务）
- `Propagation.REQUIRES_NEW (requires_new) `：支持当前事务，如果当前有事务，则挂起当前事务，然后新创建一个事务，如果当前没有事务，则自己创建一个事务。
- `Propagation.NESTED (nested 嵌套事务) ` ：如果当前存在事务，则嵌套在当前事务中。如果当前没有事务，则新建一个事务自己执行（和required一样）。嵌套的事务使用保存点作为回滚点，当内部事务回滚时不会影响外部事物的提交；但是外部回滚会把内部事务一起回滚回去。（这个和新建一个事务的区别）

#### Spring中单例bean是否线程安全

有状态的bean：对象中有实例变量（成员变量），可以保存数据，是非线程安全的

无状态的bean：对象中没有实例变量（成员变量），不能保存数据，可以在多线程环境下共享，是线程安全的

在`spring`中，绝大部分bean都是无状态的，因此即使这些bean默认是单例的，也不会出现线程安全问题的。比如`controller`、`service`、`dao`这些类，这些类里面通常不会含有成员变量，因此它们被设计成单例的。如果这些类中定义了实例变量，就线程不安全了，所以尽量避免定义实例变量。
对于`spring`中有状态的bean，比如`RequestContextHolder`、`TransactionSynchronizationManager`、`LocaleContextHolder`，为什么也能够设计成单例的呢？它是怎么保证线程安全的？
对于有状态的bean，`spring`采用`ThreadLocal`进行处理，使它们成为线程安全可以共享的对象

#### Spring中使用了哪些设计模式及应用场景

- 工厂方法：实现`FactoryBean`接口
- 单例模式：`Spring`依赖注入Bean实例默认单例
- 适配器模式：`SpringMVC`中的适配器`HandlerAdatper`
- 装饰器模式：`Spring`中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。
- 代理模式：`AOP`底层，使用动态代理实现
- 观察者模式：spring的事件驱动模型使用的是观察者模式，Spring中Observer模式常用的地方是listener的实现。
- 模版方法：父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现 

#### Spring事务的隔离级别有哪些

1. `DEFAULT` （默认） 

   这是一个`PlatfromTransactionManager`默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与`JDBC`的隔离级别相对。

2. `READ_UNCOMMITTED `（读未提交）

3. `READ_COMMITTED `（读已提交）

4. `REPEATABLE_READ `（可重复读）

5. `SERIALIZABLE`（串行化）

#### Spring事务的实现原理

#### Spring事务什么时候会失效

#### Spring是如何简化开发的

#### Spring支持的bean作用域有哪些

#### 简述Myisam和innodb的区别

#### 简述MySQL中索引类型有哪些，以及对数据库的性能影响

#### 简述Spring Bean的生命周期

#### 如何处理MySQL的慢查询

#### 如何理解Spring的starter

#### 如何实现一个IOC容器

#### 什么是MVCC

#### 什么是MySQL主从复制

#### 什么是嵌入式服务器，为什么使用嵌入式服务器

#### 什么是自动装配，它有哪些方式

#### 使用Spring的优势

#### 事务的基本特性是什么

#### 说说你对AOP的理解

#### 说说你对IOC的理解

#### 说说你对Spring的理解

#### 索引的设计原则有哪些

#### 为什么HashMap扩容的时候是两倍

#### SpringCloud的核心组件有哪些，分别有什么作用

#### 微服务架构的原理是什么

#### 注册中心的原理是什么

#### 配置中心的原理是什么

#### 注册中心是如何实现自动刷新的

#### 配置中心是如何保证数据安全的

#### 用zookeeper和Eureka做注册中心有什么区别

#### SpringCloud和Dubbo有哪些区别

#### Ribbon负载均衡原理是什么

#### 微服务熔断降级机制是什么

#### ZAB协议是什么

#### 注册中心挂了，或者服务挂了，应该如何处理

#### kafka的rebalance机制是什么

#### kafka是pull还是push，分析一下优劣

#### kafka消息丢失的场景有哪些

#### kafka中zookeeper作用是什么

#### kafka中高性能如何保障

#### rabbitmq的架构设计

#### rabbitmq的事务消息处理

#### rabbitmq如何保证消息的发送和接收

#### rabbitmq死信队列，延迟队列

#### redis持久化rdb和aof

#### redis单线程为什么这么快，有哪些线程模型

#### redis的过期键有哪些删除策略

#### redis缓存如何回收

#### redis集群有哪些方案

#### redis事务是如何实现的

#### redis主从复制原理

#### zookeeper的watch机制是什么

#### zookeeper的命名、配置、管理是如何实现的

#### zookeeper的数据模型和节点类型

#### 缓存击穿、穿透、雪崩、预热解决方案

#### 简述kafka架构设计